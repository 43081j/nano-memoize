<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" media="all" href="../node_modules/mocha/mocha.css">
<script src="../node_modules/mocha/mocha.js" type="text/javascript"></script>
<script src="../node_modules/chai/chai.js" type="text/javascript"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
<script>
"use strict";

if (typeof Object.assign !== 'function') {
	  // Must be writable: true, enumerable: false, configurable: true
	  Object.defineProperty(Object, "assign", {
	    value: function assign(target, varArgs) { // .length of function is 2
	      'use strict';
	      if (target === null || target === undefined) {
	        throw new TypeError('Cannot convert undefined or null to object');
	      }

	      var to = Object(target);

	      for (var index = 1; index < arguments.length; index++) {
	        var nextSource = arguments[index];

	        if (nextSource !== null && nextSource !== undefined) { 
	          for (var nextKey in nextSource) {
	            // Avoid bugs when hasOwnProperty is shadowed
	            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }
	      return to;
	    },
	    writable: true,
	    configurable: true
	  });
	}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function () {
	var _this = this;

	var vrgs = function vrgs(f) {
		var s = f + "",
		    i = s.indexOf("...");
		return i >= 0 && i < s.indexOf(")" || s.indexOf("arguments") >= 0);
	},
	    nanomemoize = function nanomemoize(fn) {
		var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		var serializer = _ref.serializer;
		var equals = _ref.equals;
		var maxAge = _ref.maxAge;
		var maxArgs = _ref.maxArgs;
		var _ref$vargs = _ref.vargs;
		var vargs = _ref$vargs === undefined ? vrgs(fn) : _ref$vargs;

		var s = Object.create(null),
		    // single arg function key/value cache
		k = [],
		    // multiple arg function arg key cache
		v = [],
		    // multiple arg function result cache
		wm = { m: new WeakMap() },
		    d = function d(key, c) {
			return setTimeout(function () {
				c instanceof WeakMap ? c.delete(key) : delete c[key];
			}, maxAge);
		},
		    I = Infinity,
		    f,
		    // memoized function to return
		u; // flag indicating a unary arg function is in use for clear operation
		if (fn.length === 1 && !equals && !vargs) {
			// for single argument functions, just use a JS object key look-up
			// f = original function
			// s = result cache
			// wm = weakmap
			// c = cache change timeout
			// p = arg serializer
			// a = the arguments
			f = function (f, s, wm, c, p, a) {
				// pre-bind core arguments, faster than using a closure or passing on stack
				// strings must be serialized because cache[1] should not equal or overwrite cache["1"] for value = 1 and value = "1"
				var t = typeof a === "undefined" ? "undefined" : _typeof(a);
				// set chng timeout only when new value computed, hits will not push out the tte, but it is arguable they should not
				if (!p && (t === "object" || t === "function")) {
					var r;
					return wm.m.get(a) || (!c || c(a, wm.m), wm.m.set(a, r = fn.call(this, a)), r);
				}
				var key = t === "number" || t === "boolean" || t === "undefined" ? a : t === "string" ? JSON.stringify(a) : p(a);
				return s[key] || (!c || c(key, s), s[key] = fn.call(this, a));
			}.bind(_this, fn, s, wm, maxAge > 0 && maxAge < I ? d : 0, serializer);
			u = 1;
		} else {
			// for multiple arg functions, loop through a cache of all the args
			// looking at each arg separately so a test can abort as soon as possible
			// f = original function
			// k = arg cache
			// v = results cache
			// e = equality tester
			// c = cache change timeout
			// m = maxArgs
			// ...a = the arguments
			f = function (f, k, v, e, c, m) {
				for (var _len = arguments.length, a = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
					a[_key - 6] = arguments[_key];
				}

				var i,
				    j,
				    l = m || a.length; // use var, slightly smaller and faster for loops, and i needs more scope
				for (i = 0; i < k.length && v[i] !== undefined; i++) {
					// an array of arrays of args, each array represents a call signature
					for (j = 0; j <= l && (k[i][j] === a[j] || e && e(k[i][j], a[j])); j++) {
						// compare each arg									//if(p[j]!==a[j] && (!e || !e(p[j],a[j]))) break; // go to next call signature if args don't match
						if (j === l) return v[i]; // the args matched
					}
				}
				// set chng timeout only when new value computed, hits will not push out the tte, but it is arguable they should not
				!c || c(i, v);
				return v[i] = fn.apply(this, k[i] = a);
			}.bind(_this, fn, k, v, equals, maxAge > 0 && maxAge < I ? d : 0, maxArgs);
		}
		// reset all the caches, must change array length or delete keys on objects to retain bind integrity
		f.clear = function (_) {
			Object.keys(s).forEach(function (k) {
				return delete s[k];
			});
			wm.m = new WeakMap();
			k.length = 0;
			v.length = 0;
		};
		f.keys = function (_) {
			return u ? null : k.slice();
		};
		f.values = function (_) {
			return u ? null : v.slice();
		};
		f.keyValues = function (_) {
			return u ? { primitives: Object.assign({}, s), objects: wm.m } : null;
		};
		return f;
	};
	if (typeof module !== "undefined") module.exports = nanomemoize;
	if (typeof window !== "undefined") window.nanomemoize = nanomemoize;
}).call(undefined);
</script>
</head>
<body>
<div id="mocha"></div>
<div id="messages"></div>
<div id="fixtures"></div>
<div id="app"></div>
<script>
mocha.setup('bdd');
var expect = chai.expect;
</script>

<script src="./index.js"></script>

<script>
mocha.run();
</script>
</body>
</html>
					
					